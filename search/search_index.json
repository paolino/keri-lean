{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"keri-lean","text":"<p>Lean 4 formalization of KERI (Key Event Receipt Infrastructure) protocol invariants.</p> <p>This project extracts and proves the core invariants of KERI \u2014 the protocol for decentralized key management \u2014 as machine-checked theorems in Lean 4.</p> <pre><code>graph TD\n    KERI[\"KERI Protocol\"] --&gt; |formalized as| LEAN[\"Lean 4 Theorems\"]\n    LEAN --&gt; CRYPTO[\"Crypto axioms\"]\n    LEAN --&gt; CESR[\"CESR encoding\"]\n    LEAN --&gt; EVENT[\"Event structure\"]\n    LEAN --&gt; KEYSTATE[\"Key state machine\"]\n    LEAN --&gt; KEL[\"KEL integrity\"]\n    LEAN --&gt; PREROT[\"Pre-rotation\"]\n</code></pre> <p>The formalization covers:</p> <ul> <li>Cryptographic primitives \u2014 axiomatized abstract types for digests, signatures, and keys</li> <li>CESR encoding \u2014 derivation code sizes and roundtrip properties</li> <li>Event structure \u2014 generic hash-chained event logs parameterized over payloads</li> <li>Key state machine \u2014 transition rules and their correctness</li> <li>KEL integrity \u2014 hash chain validity and replay properties</li> <li>Pre-rotation \u2014 commitment scheme for forward-secure key rotation</li> </ul>"},{"location":"#companion-projects","title":"Companion projects","text":"Project Role keri-hs Haskell implementation of KERI primitives kelgroups Governance layer built on KERI (imports keri-lean)"},{"location":"#build","title":"Build","text":"<pre><code>lake build\n</code></pre> <p>Requires Lean 4.27.0 (version pinned in <code>lean-toolchain</code>).</p>"},{"location":"#no-sorry-no-custom-axioms","title":"No sorry, no custom axioms","text":"<p>All theorems compile without <code>sorry</code>. The only axioms are:</p> <ul> <li>Standard Lean axioms (<code>propext</code>, <code>Classical.choice</code>, <code>Quot.sound</code>)</li> <li>Explicitly declared crypto axioms (signature verification, hash determinism, commitment correctness) \u2014 these model assumptions about the underlying cryptographic implementations that cannot be proven without concrete algorithms</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Features needed in keri-lean (and their keri-hs / keri-purs implementations) to support the kelgroups roadmap.</p>"},{"location":"roadmap/#current-state","title":"Current state","text":""},{"location":"roadmap/#formalized-in-keri-lean","title":"Formalized in keri-lean","text":"Module What it covers <code>KERI.Crypto</code> Abstract primitives: keys, signatures, digests, hashing (4 axioms) <code>KERI.CESR</code> Derivation codes, encoding sizes, roundtrip property <code>KERI.Event</code> Generic <code>KELEvent \u03b1</code>, KERI <code>EventPayload</code> (Icp/Rot/Ixn/Rct), event classification <code>KERI.SAID</code> SAID verification: <code>verifySAID</code>, <code>computeSAID</code>, <code>claimedDigest</code> (2 axioms, 3 theorems) <code>KERI.KeyState</code> State machine: <code>initialState</code>, <code>applyEvent</code> with SAID guard, pre-rotation (8 theorems) <code>KERI.KEL</code> Hash chain validity, replay, signature threshold (5 theorems) <code>KERI.PreRotation</code> Commitment scheme: <code>commitKey</code>, <code>verifyPreRotation</code> (3 theorems)"},{"location":"roadmap/#implemented-in-keri-hs-keri-purs","title":"Implemented in keri-hs / keri-purs","text":"Feature keri-hs module keri-purs module CESR encoding/decoding <code>Keri.Cesr.*</code> <code>Keri.Cesr.*</code> Ed25519 signatures <code>Keri.Crypto.Ed25519</code> <code>Keri.Crypto.Ed25519</code> Blake3 digest (via Blake2b) <code>Keri.Crypto.Digest</code> <code>Keri.Crypto.Digest</code> Event creation (icp/rot/ixn) <code>Keri.Event.Inception</code>, <code>.Rotation</code>, <code>.Interaction</code> same SAID verification <code>Keri.Crypto.SAID</code> <code>Keri.Crypto.SAID</code> KEL append + replay <code>Keri.Kel.Append</code>, <code>Keri.Kel.Replay</code> same Key state machine <code>Keri.KeyState</code> <code>Keri.KeyState</code> Signature verification <code>Keri.KeyState.Verify</code> <code>Keri.KeyState.Verify</code> Pre-rotation commitment <code>Keri.KeyState.PreRotation</code> <code>Keri.KeyState.PreRotation</code>"},{"location":"roadmap/#roadmap_1","title":"Roadmap","text":""},{"location":"roadmap/#1-identifier-creation-helper-kelgroups-step-10","title":"1. Identifier creation helper (kelgroups Step 10)","text":"<p>Status: not started Needed for: KEL-managed identities in kelgroups</p> <p>Currently the caller has to orchestrate <code>mkInception</code> + sign + <code>append emptyKel</code> manually. Provide a convenience function that creates an inception event, signs it, appends to a new KEL, and returns the prefix + KEL.</p> <p>keri-hs / keri-purs:</p> <ul> <li>New function in <code>Keri.Kel</code>: <code>createIdentifier :: KeyPair -&gt; InceptionConfig -&gt; Either String (Prefix, Kel)</code></li> <li>Wraps the inception + sign + append sequence</li> </ul> <p>keri-lean:</p> <ul> <li>No new formalization needed \u2014 <code>initialState</code> and <code>replay</code> already cover inception</li> </ul>"},{"location":"roadmap/#2-witness-threshold-enforcement-kelgroups-step-12","title":"2. Witness threshold enforcement (kelgroups Step 12)","text":"<p>Status: not started Needed for: witness receipts</p> <p><code>InceptionConfig</code> has <code>icWitnesses</code> and <code>icWitnessThreshold</code>, and <code>KeyState</code> stores them, but <code>append</code> ignores witness threshold entirely. Receipt events (<code>Rct</code>) exist but are not collected or verified against witness keys.</p> <p>keri-lean:</p> <ul> <li>Formalize <code>witnessThresholdMet</code>: receipt count from distinct witnesses   meets <code>stateWitnessThreshold</code></li> <li>Add <code>witnessThresholdMet</code> as a guard in event confirmation (separate from   <code>append</code> \u2014 events can be appended but not confirmed until receipted)</li> <li>Theorem: confirmed events have sufficient witness receipts</li> </ul> <p>keri-hs / keri-purs:</p> <ul> <li>Track pending receipts per event in KEL management</li> <li><code>collectReceipt :: Kel -&gt; Receipt -&gt; Either String Kel</code> \u2014 verify receipt   signature against witness key, accumulate</li> <li><code>isConfirmed :: Kel -&gt; SequenceNumber -&gt; Bool</code> \u2014 check if witness threshold   met for a given event</li> <li>Enforce witness threshold in <code>append</code> (configurable: strict mode rejects   unreceipted events, permissive mode accepts but marks unconfirmed)</li> </ul>"},{"location":"roadmap/#3-receipt-verification-kelgroups-step-12","title":"3. Receipt verification (kelgroups Step 12)","text":"<p>Status: not started Needed for: witness receipts</p> <p>Receipt events carry a receipted event digest and a witness signature. Need to verify that the receipt references a real event and the signature matches a configured witness key.</p> <p>keri-lean:</p> <ul> <li>Formalize <code>receiptValid</code>: receipt digest matches an event in the KEL,   receipt signer is in <code>stateWitnesses</code></li> <li>Currently <code>receipt_neutral</code> proves receipts don't change state; add   <code>receipt_valid_implies_witness</code> \u2014 valid receipt signer must be a witness</li> </ul> <p>keri-hs / keri-purs:</p> <ul> <li><code>verifyReceipt :: KeyState -&gt; Kel -&gt; SignedEvent -&gt; Either String ()</code> \u2014   check receipt references existing event, signer is a witness, signature valid</li> </ul>"},{"location":"roadmap/#4-witness-rotation-kelgroups-step-12","title":"4. Witness rotation (kelgroups Step 12)","text":"<p>Status: not started Needed for: witness lifecycle management</p> <p><code>RotationConfig</code> has <code>rcWitnessConfig</code> (add/remove witnesses) but <code>applyEvent</code> ignores it \u2014 <code>KeyState.stateWitnesses</code> is set at inception and never updated.</p> <p>keri-lean:</p> <ul> <li>Update <code>applyEvent</code> for rotation to apply <code>WitnessConfig</code> changes to   <code>stateWitnesses</code></li> <li>Theorem: <code>rotation_updates_witnesses</code> \u2014 after rotation with witness config,   <code>stateWitnesses</code> reflects the additions and removals</li> </ul> <p>keri-hs / keri-purs:</p> <ul> <li>Update <code>applyEvent</code> rotation case to apply witness adds/removes</li> <li>Tests: witness rotation round-trip, receipt rejected after witness removal</li> </ul>"},{"location":"roadmap/#5-duplicity-detection-kelgroups-step-13","title":"5. Duplicity detection (kelgroups Step 13)","text":"<p>Status: not started Needed for: detecting compromised server publishing conflicting KELs</p> <p>No mechanism exists to detect two valid but conflicting KELs for the same prefix (same inception, diverging at some sequence number).</p> <p>keri-lean:</p> <ul> <li>Define <code>duplicitous</code>: two KELs share the same prefix (inception event)   but contain different events at some sequence number</li> <li>Theorem: <code>hashChainValid</code> + same inception + different event at sequence N   implies different digest chains from N onward (divergence is permanent)</li> <li>Theorem: a duplicitous pair cannot both be valid if witnesses are honest   (at least one receipt set must be forged)</li> </ul> <p>keri-hs / keri-purs:</p> <ul> <li><code>detectDuplicity :: Kel -&gt; Kel -&gt; Maybe DuplicityEvidence</code> \u2014 compare two   KELs for the same prefix, return the first divergence point</li> <li><code>DuplicityEvidence</code> contains: prefix, sequence number, the two conflicting   events, and their respective receipt sets</li> </ul>"},{"location":"roadmap/#companion-projects","title":"Companion projects","text":"Project Role Link keri-hs Haskell implementation github.com/paolino/keri-hs keri-purs PureScript implementation (browser) github.com/paolino/keri-purs kelgroups Governance layer (consumer) github.com/paolino/kelgroups"},{"location":"roadmap/#not-needed","title":"Not needed","text":"<p>These KERI features are not required by kelgroups:</p> <ul> <li>Weighted thresholds \u2014 kelgroups uses simple admin majority</li> <li>Delegated identifiers \u2014 no hierarchical delegation</li> <li>OOBI protocol \u2014 centralized server stores all participant KELs</li> <li>Indirect mode networking \u2014 direct HTTP</li> <li>Out-of-order event escrow \u2014 nice to have but not blocking</li> </ul>"},{"location":"invariants/cesr/","title":"CESR Encoding","text":"<p>Module: <code>KERI.CESR</code></p>"},{"location":"invariants/cesr/#what-is-cesr","title":"What is CESR?","text":"<p>CESR (Composable Event Streaming Representation) is KERI's binary encoding format. Each primitive consists of a derivation code prefix followed by raw cryptographic material, all Base64-encoded to a fixed total length.</p> <pre><code>graph LR\n    subgraph Primitive\n        CODE[Code prefix] --- RAW[Raw bytes]\n    end\n    Primitive --&gt;|encode| B64[Base64 string]\n    B64 --&gt;|decode| Primitive\n</code></pre>"},{"location":"invariants/cesr/#derivation-codes","title":"Derivation codes","text":"Code Prefix length Raw size (bytes) Total length (Base64 chars) <code>Ed25519PubKey</code> 1 32 44 <code>Blake2bDigest</code> 1 32 44 <code>Ed25519Sig</code> 2 64 88"},{"location":"invariants/cesr/#invariants","title":"Invariants","text":""},{"location":"invariants/cesr/#size-consistency","title":"Size consistency","text":"<p>Each derivation code determines exact sizes. The formalization proves these as definitional equalities:</p> <ul> <li><code>ed25519_pub_total_length</code> \u2014 Ed25519 public key is 44 characters</li> <li><code>blake2b_digest_total_length</code> \u2014 Blake2b digest is 44 characters</li> <li><code>ed25519_sig_total_length</code> \u2014 Ed25519 signature is 88 characters</li> </ul>"},{"location":"invariants/cesr/#construction-validity","title":"Construction validity","text":"<p><code>mkPrimitive</code> is the only way to construct a <code>Primitive</code>. It checks that the raw material size matches the derivation code:</p> <p><code>primitive_size_valid</code>: <code>mkPrimitive c r</code> succeeds if and only if <code>r.len = rawSize c</code>.</p> <p>This prevents malformed primitives from entering the system.</p>"},{"location":"invariants/cesr/#roundtrip-property","title":"Roundtrip property","text":"<pre><code>graph LR\n    P[\"Primitive (code, raw)\"] --&gt;|encode| N[Nat]\n    N --&gt;|decode| P2[\"Some (code, raw)\"]\n    P -.-|\"= (when well-formed)\"| P2\n</code></pre> <p><code>roundtrip</code>: For any well-formed primitive, <code>decode(encode(p)) = p</code>.</p> <p>This is axiomatized (since encode/decode are opaque) but the axiom requires the size precondition, ensuring only valid primitives roundtrip.</p>"},{"location":"invariants/cesr/#code-uniqueness","title":"Code uniqueness","text":"<p><code>code_lengths_distinct</code>: Different derivation codes have distinguishable prefixes (specifically, <code>Ed25519Sig</code> has code length 2 while <code>Ed25519PubKey</code> has code length 1).</p>"},{"location":"invariants/crypto/","title":"Cryptographic Primitives","text":"<p>Module: <code>KERI.Crypto</code></p>"},{"location":"invariants/crypto/#abstract-types","title":"Abstract types","text":"<p>All cryptographic types are abbreviations over <code>Nat</code>. This gives us decidable equality for free while keeping the formalization independent of any concrete implementation.</p> Type Meaning <code>Digest</code> Hash output (e.g. Blake2b-256) <code>SAID</code> Self-Addressing Identifier <code>Signature</code> Digital signature (e.g. Ed25519) <code>Key</code> Public key <code>SecretKey</code> Secret (signing) key"},{"location":"invariants/crypto/#operations","title":"Operations","text":"<pre><code>graph LR\n    SK[SecretKey] --&gt;|derivePublic| PK[Key]\n    SK --&gt;|sign| SIG[Signature]\n    PK --&gt;|verify| BOOL[Bool]\n    SIG --&gt;|verify| BOOL\n    PK --&gt;|commitKey| DIG[Digest]\n    PK --&gt;|verifyCommitment| BOOL2[Bool]\n    DIG --&gt;|verifyCommitment| BOOL2\n    ANY[Nat] --&gt;|hash| DIG2[Digest]\n</code></pre> Operation Signature Purpose <code>hash</code> <code>Nat \u2192 Digest</code> Cryptographic hash <code>sign</code> <code>SecretKey \u2192 Nat \u2192 Signature</code> Sign a message <code>verify</code> <code>Key \u2192 Nat \u2192 Signature \u2192 Bool</code> Verify a signature <code>derivePublic</code> <code>SecretKey \u2192 Key</code> Derive public key from secret <code>commitKey</code> <code>Key \u2192 Digest</code> Compute key commitment <code>verifyCommitment</code> <code>Key \u2192 Digest \u2192 Bool</code> Check key against commitment <p>All operations are declared <code>opaque</code> \u2014 their implementations are not visible to the prover, ensuring theorems rely only on the stated axioms.</p>"},{"location":"invariants/crypto/#axioms","title":"Axioms","text":"<pre><code>graph TD\n    subgraph sign_verify\n        SK1[sk] --&gt;|sign| SIG1[sig]\n        SK1 --&gt;|derivePublic| PK1[pk]\n        PK1 --&gt;|\"verify pk msg sig\"| TRUE1[\"true \u2713\"]\n        SIG1 --&gt;|\"verify pk msg sig\"| TRUE1\n    end\n    subgraph commit_verify\n        K1[k] --&gt;|commitKey| C1[commitment]\n        K1 --&gt;|\"verifyCommitment k c\"| TRUE2[\"true \u2713\"]\n        C1 --&gt;|\"verifyCommitment k c\"| TRUE2\n    end\n</code></pre>"},{"location":"invariants/crypto/#sign_verify","title":"<code>sign_verify</code>","text":"<p>Signing with a secret key and verifying with the corresponding public key always succeeds.</p> <pre><code>verify (derivePublic sk) msg (sign sk msg) = true\n</code></pre> <p>This is the fundamental correctness assumption for any digital signature scheme.</p>"},{"location":"invariants/crypto/#commit_verify","title":"<code>commit_verify</code>","text":"<p>A key always passes verification against its own commitment.</p> <pre><code>verifyCommitment k (commitKey k) = true\n</code></pre> <p>This models the pre-rotation commitment mechanism: if you publish <code>commitKey(k)</code> now, you can later reveal <code>k</code> and anyone can verify the commitment.</p>"},{"location":"invariants/crypto/#proven-theorems","title":"Proven theorems","text":"<ul> <li><code>commitment_deterministic</code> \u2014 <code>commitKey</code> is a function (same input, same output)</li> <li><code>commitment_verify_correct</code> \u2014 direct consequence of <code>commit_verify</code> axiom</li> <li><code>sign_then_verify</code> \u2014 direct consequence of <code>sign_verify</code> axiom</li> </ul>"},{"location":"invariants/event/","title":"Event Structure","text":"<p>Module: <code>KERI.Event</code></p>"},{"location":"invariants/event/#generic-kel-events","title":"Generic KEL events","text":"<p>The <code>KELEvent</code> structure is parameterized over a payload type <code>\u03b1</code>, making it reusable across different KERI-based protocols:</p> <pre><code>structure KELEvent (\u03b1 : Type) where\n  sequenceNumber : Nat\n  priorDigest : Option Digest\n  payload : \u03b1\n  signer : Key\n  signature : Signature\n</code></pre> <p>A <code>KEL \u03b1</code> is simply <code>List (KELEvent \u03b1)</code>, stored newest-first.</p> <p>This structure was originally defined in kelgroups and is extracted here so any KERI-based project can import it.</p>"},{"location":"invariants/event/#keri-event-payloads","title":"KERI event payloads","text":"<pre><code>graph TD\n    EP[EventPayload]\n    EP --&gt; ICP[\"IcpInception\"]\n    EP --&gt; ROT[\"RotRotation\"]\n    EP --&gt; IXN[\"IxnInteraction\"]\n    EP --&gt; RCT[\"RctReceipt\"]\n\n    ICP -.- ICP_D[\"prefix, keys,next-key commitments,witnesses\"]\n    ROT -.- ROT_D[\"new keys,new commitments,witness changes\"]\n    IXN -.- IXN_D[\"data anchors(digests)\"]\n    RCT -.- RCT_D[\"receiptedevent digest\"]\n</code></pre> Type Purpose Key fields Icp (Inception) Establish new identifier prefix, keys, next-key commitments, witnesses Rot (Rotation) Rotate keys new keys, new next-key commitments, witness changes Ixn (Interaction) Anchor external data data anchors (digests) Rct (Receipt) Witness receipt receipted event digest"},{"location":"invariants/event/#inception","title":"Inception","text":"<p>Creates a new KERI identifier. Fields:</p> <ul> <li><code>prefix</code> \u2014 the SAID (self-addressing identifier), computed as the digest of the inception event itself</li> <li><code>signingThreshold</code> \u2014 minimum signatures required (multi-sig)</li> <li><code>keys</code> \u2014 current signing key set</li> <li><code>nextThreshold</code> / <code>nextKeys</code> \u2014 pre-rotation commitments for the next key set</li> <li><code>witnessThreshold</code> / <code>witnesses</code> \u2014 witness configuration</li> </ul>"},{"location":"invariants/event/#rotation","title":"Rotation","text":"<p>Replaces the current key set with previously committed next-keys. Supports witness configuration changes.</p>"},{"location":"invariants/event/#interaction","title":"Interaction","text":"<p>Anchors arbitrary data (as digests) to the KEL without changing keys. Used for binding external events to the identifier's timeline.</p>"},{"location":"invariants/event/#receipt","title":"Receipt","text":"<p>A non-transferable witness receipt. Does not modify key state.</p>"},{"location":"invariants/event/#invariants","title":"Invariants","text":"<ul> <li><code>inception_type</code> / <code>rotation_type</code> \u2014 <code>eventType</code> correctly classifies payloads</li> <li><code>prefix_consistent_icp</code> / <code>prefix_consistent_rot</code> \u2014 <code>eventPrefix</code> extracts the prefix field from any payload variant</li> </ul>"},{"location":"invariants/kel/","title":"KEL Integrity","text":"<p>Module: <code>KERI.KEL</code></p>"},{"location":"invariants/kel/#hash-chain-validity","title":"Hash chain validity","text":"<pre><code>graph LR\n    E0[\"Event 0seq=0prior=none\"] --&gt; E1[\"Event 1seq=1prior=H(E0)\"]\n    E1 --&gt; E2[\"Event 2seq=2prior=H(E1)\"]\n    E2 --&gt; E3[\"Event 3seq=3prior=H(E2)\"]\n    E3 --&gt; EN[\"...\"]\n</code></pre> <p>The fundamental integrity property of any KEL is its hash chain: each event (except inception) links to its predecessor via a prior digest, and sequence numbers form a contiguous sequence starting from 0.</p> <pre><code>def hashChainValid (kel : KEL \u03b1) : Prop :=\n  match kel with\n  | [] =&gt; True\n  | [e] =&gt; e.sequenceNumber = 0 \u2227 e.priorDigest = none\n  | e :: rest =&gt;\n    e.priorDigest.isSome\n    \u2227 (match rest.head? with\n       | some prev =&gt; e.sequenceNumber = prev.sequenceNumber + 1\n       | none =&gt; False)\n    \u2227 hashChainValid rest\n</code></pre> <p>This definition is recursive over the list (newest-first). The base cases are:</p> <ul> <li>Empty list: trivially valid</li> <li>Single event: must be inception (seq 0, no prior digest)</li> <li>Cons: must have a prior digest, sequence number one more than predecessor, and the rest must be valid</li> </ul>"},{"location":"invariants/kel/#proven-invariants","title":"Proven invariants","text":""},{"location":"invariants/kel/#singleton_chain_valid","title":"<code>singleton_chain_valid</code>","text":"<p>A single event with sequence number 0 and no prior digest forms a valid chain.</p> <p>This is the base case: every KEL starts with a single inception event.</p>"},{"location":"invariants/kel/#kel_starts_with_inception","title":"<code>kel_starts_with_inception</code>","text":"<p>In any valid non-empty KEL, there exists an event with sequence number 0 and no prior digest.</p> <p>This proves that the inception event is always present \u2014 you can't have a valid KEL that starts mid-stream.</p>"},{"location":"invariants/kel/#replay_empty_fails","title":"<code>replay_empty_fails</code>","text":"<p>Replaying an empty event list produces no state.</p> <p>You need at least an inception event.</p>"},{"location":"invariants/kel/#replay_inception_gives_initial","title":"<code>replay_inception_gives_initial</code>","text":"<p>Replaying a single valid inception event produces the same state as <code>initialState</code>.</p> <p>This connects the replay function to the initialization function.</p>"},{"location":"invariants/kel/#threshold_zero_met","title":"<code>threshold_zero_met</code>","text":"<p>A signature threshold of 0 is satisfied by any number of signatures.</p> <p>This handles the degenerate case (useful for testing).</p>"},{"location":"invariants/kel/#replay-function","title":"Replay function","text":"<pre><code>graph LR\n    EVENTS[\"[Icp, Rot, Ixn, ...]\"] --&gt; INIT[\"initialState(Icp)\"]\n    INIT --&gt;|\"some ks\u2080\"| FOLD[\"foldlM applyEvent\"]\n    INIT --&gt;|none| FAIL1[none]\n    FOLD --&gt;|\"some ks_n\"| FINAL[\"Final KeyState\"]\n    FOLD --&gt;|none| FAIL2[\"none (invalid event)\"]\n</code></pre> <p><code>replay</code> processes events oldest-first:</p> <ol> <li>The first event must be a valid inception (via <code>initialState</code>)</li> <li>Each subsequent event is applied via <code>applyEvent</code></li> <li>Any failure short-circuits to <code>none</code></li> </ol>"},{"location":"invariants/keystate/","title":"Key State Machine","text":"<p>Module: <code>KERI.KeyState</code></p>"},{"location":"invariants/keystate/#key-state","title":"Key state","text":"<p>The key state is the cumulative result of processing a KEL from inception through all subsequent events:</p> Field Type Meaning <code>prefix</code> SAID Identifier (immutable after inception) <code>sequenceNumber</code> Nat Current sequence number <code>lastDigest</code> Digest Digest of the most recent event <code>signingThreshold</code> Nat Required signature count <code>keys</code> List Key Current signing keys <code>nextThreshold</code> Nat Threshold for next key set <code>nextKeys</code> List Digest Commitments to next keys <code>witnessThreshold</code> Nat Required witness receipt count <code>witnesses</code> List Key Current witness set"},{"location":"invariants/keystate/#state-transitions","title":"State transitions","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; KeyState: Icp (initialState)\n    KeyState --&gt; KeyState: Rot (rotate keys)\n    KeyState --&gt; KeyState: Ixn (anchor data)\n    KeyState --&gt; KeyState: Rct (no-op)\n\n    note right of KeyState\n        Guards checked on every transition:\n        - seqNum = prev + 1\n        - prefix matches\n        - not Icp\n    end note\n</code></pre>"},{"location":"invariants/keystate/#initialstate","title":"<code>initialState</code>","text":"<p>Creates the initial key state from an inception event. Requires:</p> <ul> <li>Sequence number = 0</li> <li>No prior digest</li> </ul>"},{"location":"invariants/keystate/#applyevent","title":"<code>applyEvent</code>","text":"<pre><code>graph TD\n    E[Event] --&gt; CHK_SEQ{\"seqNum =state.seqNum + 1?\"}\n    CHK_SEQ --&gt;|no| NONE1[none]\n    CHK_SEQ --&gt;|yes| CHK_PFX{\"prefixmatches?\"}\n    CHK_PFX --&gt;|no| NONE2[none]\n    CHK_PFX --&gt;|yes| CHK_TYPE{\"event type?\"}\n    CHK_TYPE --&gt;|Icp| NONE3[\"none (rejected)\"]\n    CHK_TYPE --&gt;|Rot| ROT[\"Update keys,next-key commitments,witnesses\"]\n    CHK_TYPE --&gt;|Ixn| IXN[\"Update seqNum,lastDigest\"]\n    CHK_TYPE --&gt;|Rct| RCT[\"Return stateunchanged\"]\n</code></pre> <p>Applies a non-inception event to an existing state. Validates:</p> <ol> <li>Sequence number = current + 1</li> <li>Prefix matches</li> <li>Event type is not inception</li> </ol> <p>Then updates the state according to the event type:</p> <ul> <li>Rotation: replaces keys, next-key commitments, updates witnesses</li> <li>Interaction: increments sequence number, updates last digest</li> <li>Receipt: no-op (state unchanged)</li> </ul>"},{"location":"invariants/keystate/#proven-invariants","title":"Proven invariants","text":""},{"location":"invariants/keystate/#initialization","title":"Initialization","text":"<ul> <li><code>initial_state_seq_zero</code> \u2014 The initial state always has sequence number 0</li> <li><code>initial_state_prefix</code> \u2014 The initial state's prefix matches the inception event's prefix</li> </ul>"},{"location":"invariants/keystate/#transition-guards","title":"Transition guards","text":"<ul> <li><code>apply_rejects_inception</code> \u2014 You cannot apply an inception event to an existing state. Inception is only valid as the first event.</li> <li><code>apply_checks_sequence</code> \u2014 A successful <code>applyEvent</code> requires <code>e.sequenceNumber = ks.sequenceNumber + 1</code>. Events cannot be applied out of order.</li> <li><code>apply_checks_prefix</code> \u2014 A successful <code>applyEvent</code> requires the event's prefix to match the state's prefix. Events for a different identifier are rejected.</li> </ul>"},{"location":"invariants/keystate/#state-updates","title":"State updates","text":"<ul> <li><code>receipt_neutral</code> \u2014 Receipt events leave the key state unchanged. They are acknowledgments, not mutations.</li> <li><code>apply_updates_sequence</code> \u2014 For non-receipt events, a successful application increments the sequence number by exactly 1.</li> </ul>"},{"location":"invariants/overview/","title":"Invariant Overview","text":"<p>KERI's security rests on a small set of invariants that must hold across all event processing. This formalization makes them explicit and machine-checked.</p>"},{"location":"invariants/overview/#module-dependency-graph","title":"Module dependency graph","text":"<pre><code>graph TD\n    Crypto[\"KERI.CryptoAbstract primitives\"]\n    CESR[\"KERI.CESREncoding properties\"]\n    Event[\"KERI.EventKELEvent, payloads\"]\n    SAID[\"KERI.SAIDSAID verification\"]\n    KeyState[\"KERI.KeyStateState machine\"]\n    KEL[\"KERI.KELHash chain, replay\"]\n    PreRot[\"KERI.PreRotationCommitment scheme\"]\n\n    Crypto --&gt; CESR\n    Crypto --&gt; Event\n    Crypto --&gt; SAID\n    Crypto --&gt; PreRot\n    Event --&gt; SAID\n    SAID --&gt; KeyState\n    Event --&gt; KeyState\n    Event --&gt; KEL\n    KeyState --&gt; KEL\n</code></pre> <p><code>Crypto</code> provides the abstract primitives. <code>Event</code> defines the generic event structure (shared with kelgroups). <code>SAID</code> models self-addressing identifier verification. <code>KeyState</code>, <code>KEL</code>, and <code>PreRotation</code> build the KERI-specific invariants on top.</p>"},{"location":"invariants/overview/#axiom-theorem-boundary","title":"Axiom / theorem boundary","text":"<pre><code>graph LR\n    subgraph Axioms[\"Axioms (crypto assumptions)\"]\n        A1[sign_verify]\n        A2[hash_deterministic]\n        A3[commit_verify]\n        A4[roundtrip_ax]\n        A5[said_creation_correct]\n        A6[inception_prefix_is_said]\n    end\n    subgraph Theorems[\"Theorems (proven)\"]\n        T1[sign_then_verify]\n        T2[commitment_verify_correct]\n        T3[roundtrip]\n        T4[primitive_size_valid]\n        T5[initial_state_seq_zero]\n        T6[kel_starts_with_inception]\n        T7[verify_prerotation_correct]\n        T8[verify_said_correct]\n        T9[initial_state_requires_said]\n    end\n\n    A1 --&gt; T1\n    A3 --&gt; T2\n    A3 --&gt; T7\n    A4 --&gt; T3\n    A5 --&gt; T8\n    A6 --&gt; T9\n</code></pre> <p>Axioms are assumptions about the cryptographic layer that cannot be proven without a concrete implementation:</p> Axiom Module Meaning <code>sign_verify</code> Crypto Signatures produced by <code>sign</code> are accepted by <code>verify</code> <code>hash_deterministic</code> Crypto Hashing is a function <code>commit_verify</code> Crypto <code>verifyCommitment(k, commitKey(k))</code> succeeds <code>roundtrip_ax</code> CESR <code>decode(encode(p)) = p</code> for well-formed primitives <code>said_creation_correct</code> SAID Events built via SAID protocol pass <code>verifySAID</code> <code>inception_prefix_is_said</code> SAID For verified inception, prefix = <code>claimedDigest</code> <p>Theorems are proven consequences that follow from the definitions and axioms:</p> Count Module Examples 3 Crypto <code>sign_then_verify</code>, <code>commitment_verify_correct</code> 7 CESR <code>ed25519_pub_total_length</code>, <code>roundtrip</code>, <code>primitive_size_valid</code> 4 Event <code>inception_type</code>, <code>prefix_consistent_icp</code> 3 SAID <code>verify_said_correct</code>, <code>verify_said_implies_authentic</code>, <code>self_addressing_verified</code> 8 KeyState <code>initial_state_seq_zero</code>, <code>apply_rejects_inception</code>, <code>receipt_neutral</code>, <code>initial_state_requires_said</code>, <code>apply_requires_said</code> 5 KEL <code>singleton_chain_valid</code>, <code>kel_starts_with_inception</code>, <code>replay_inception_gives_initial</code> 3 PreRotation <code>commit_verify_roundtrip</code>, <code>verify_prerotation_singleton</code>"},{"location":"invariants/overview/#relationship-to-kelgroups","title":"Relationship to kelgroups","text":"<pre><code>graph TD\n    subgraph keri-lean[\"keri-lean (this repo)\"]\n        KE[\"KELEvent \u03b1\"]\n        HC[\"hashChainValid\"]\n        CR[\"Crypto types\"]\n    end\n    subgraph kelgroups[\"kelgroups\"]\n        L1[\"L1 / L2 payloads\"]\n        GOV[\"Governance invariants\"]\n        FOLD[\"FoldInvariants\"]\n    end\n\n    CR --&gt; KE\n    KE --&gt; HC\n    KE --&gt;|\"require keri\"| L1\n    HC --&gt;|\"require keri\"| GOV\n    L1 --&gt; GOV\n    GOV --&gt; FOLD\n</code></pre> <p>The <code>KELEvent</code> structure and <code>hashChainValid</code> predicate were originally defined in kelgroups. This project extracts the generic KERI parts so that kelgroups (and any other KERI-based project) can depend on them via Lake's <code>require</code> mechanism.</p>"},{"location":"invariants/prerotation/","title":"Pre-Rotation","text":"<p>Module: <code>KERI.PreRotation</code></p>"},{"location":"invariants/prerotation/#the-pre-rotation-mechanism","title":"The pre-rotation mechanism","text":"<pre><code>sequenceDiagram\n    participant Owner\n    participant KEL\n\n    Note over Owner,KEL: Inception / Rotation\n    Owner-&gt;&gt;KEL: Publish commitKey(nextKey\u2081), commitKey(nextKey\u2082)\n    Note over KEL: Commitments stored in key state\n\n    Note over Owner,KEL: Later: Key Rotation\n    Owner-&gt;&gt;KEL: Reveal nextKey\u2081, nextKey\u2082\n    KEL-&gt;&gt;KEL: verifyCommitment(nextKey\u2081, commitment\u2081)?\n    KEL-&gt;&gt;KEL: verifyCommitment(nextKey\u2082, commitment\u2082)?\n    KEL--&gt;&gt;Owner: Rotation accepted\n\n    Note over Owner,KEL: Attacker scenario\n    Owner-&gt;&gt;KEL: Attacker has current keys but NOT next keys\n    KEL--xOwner: Cannot forge rotation (commitments don't match)\n</code></pre> <p>Pre-rotation is KERI's key innovation for forward-secure key management. The idea:</p> <ol> <li>At inception (or rotation), you publish commitments to your next key set \u2014 <code>commitKey(nextKey)</code> for each key</li> <li>When you rotate, you reveal the actual keys and prove they match the commitments</li> <li>An attacker who compromises your current keys cannot rotate to their own keys because they don't know which keys match the published commitments</li> </ol> <p>This creates a one-time-pad-like protection: even with full access to current signing keys, an attacker cannot forge a valid rotation without the pre-committed next keys.</p>"},{"location":"invariants/prerotation/#verification","title":"Verification","text":"<p><code>verifyPreRotation</code> checks two things:</p> <ol> <li>Length match: the number of revealed keys equals the number of commitments</li> <li>Commitment match: each key's commitment equals the corresponding published commitment</li> </ol> <pre><code>def verifyPreRotation (keys : List Key) (commitments : List Digest) : Bool :=\n  keys.length = commitments.length\n  &amp;&amp; keys.zip commitments |&gt;.all fun (k, c) =&gt; verifyCommitment k c\n</code></pre>"},{"location":"invariants/prerotation/#proven-invariants","title":"Proven invariants","text":""},{"location":"invariants/prerotation/#commit_verify_roundtrip","title":"<code>commit_verify_roundtrip</code>","text":"<p><code>verifyCommitment k (commitKey k) = true</code></p> <p>The fundamental soundness property: if you commit to a key and later reveal it, the verification succeeds. This follows directly from the <code>commit_verify</code> axiom in <code>Crypto</code>.</p>"},{"location":"invariants/prerotation/#verify_prerotation_length","title":"<code>verify_prerotation_length</code>","text":"<p>If <code>verifyPreRotation</code> succeeds, then <code>keys.length = commitments.length</code>.</p> <p>Pre-rotation requires exactly as many keys as there were commitments. You can't add or remove keys during rotation without them being pre-committed.</p>"},{"location":"invariants/prerotation/#verify_prerotation_empty","title":"<code>verify_prerotation_empty</code>","text":"<p>Empty key sets trivially pass verification.</p> <p>Base case for inductive reasoning.</p>"},{"location":"invariants/prerotation/#verify_prerotation_singleton","title":"<code>verify_prerotation_singleton</code>","text":"<p>A single correctly committed key passes verification.</p> <p>The minimal non-trivial case.</p>"},{"location":"invariants/prerotation/#verify_prerotation_correct","title":"<code>verify_prerotation_correct</code>","text":"<p>If all keys are correctly committed (<code>commitments = keys.map commitKey</code>), verification passes.</p> <p>This is the completeness property: the happy path always works. Combined with the length check, it shows that <code>verifyPreRotation</code> accepts exactly the right inputs.</p>"}]}